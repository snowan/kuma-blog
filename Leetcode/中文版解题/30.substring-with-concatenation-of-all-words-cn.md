## é¢˜ç›®åœ°å€
https://leetcode.com/problems/substring-with-concatenation-of-all-words/

## é¢˜ç›®æè¿°
```
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s)
in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:
Input:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.

Example 2:
Input:
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
Output: []
```

## æ€è·¯
é¢˜æ„: ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²`(String s)`, ç»™å®š`n`ä¸ªå•è¯ç»„æˆçš„å­—ç¬¦ä¸²æ•°ç»„`(String[] words)`, æ‰¾å‡ºæ‰€æœ‰å­ä¸²`(substring)`çš„èµ·å§‹ä¸‹æ ‡`(start index)`, 
ä½¿å¾—è¯¥å­ä¸²åŒ…å«æ‰€æœ‰çš„å•è¯, æ¯ä¸ªå•è¯çš„ä¸ªæ•°ä¹Ÿè¦ç›¸åŒ(å­ä¸²ä¸­å•è¯é¡ºåºä»»æ„).

#### è§£æ³•ä¸€ - æš´åŠ›

å…ˆç®€å•,ç›´æ¥,æš´åŠ›çš„è§£ (æš´åŠ›å‡ºå¥‡è¿¹, ğŸ˜„).

éå†å­—ç¬¦`s`,åˆ¤æ–­æ¯ä¸ªå­ä¸²æ˜¯åŒ¹é…å­—ç¬¦ä¸²æ•°ç»„ä¸­æ‰€æœ‰å•è¯, å¦‚æœåŒ¹é…, è®°å½•ä¸‹æ ‡ (`index`), æ¡ä»¶ä¸­æ¯ä¸ªå•è¯çš„é•¿åº¦æ˜¯ç›¸åŒçš„, æ‰€ä»¥ä»å½“å‰ä¸‹æ ‡, å¯ä»¥å¾ˆå¿«å¾—åˆ°å•è¯é•¿åº¦çš„å­ä¸²å¹¶è¿›è¡Œæ¯”è¾ƒ.

ç”±äºä¸è€ƒè™‘é¡ºåº,è¿™é‡Œå¯ä»¥ç”¨`Hashmap`å…ˆä¿å­˜æ‰€æœ‰å•è¯,å¹¶è®°å½•å•è¯å‡ºç°çš„æ¬¡æ•°. `Map<Key, Value> `- `key` æ˜¯å•è¯, `value` æ˜¯å•è¯çš„ä¸ªæ•°.

éå†å­—ç¬¦`s`çš„æ—¶å€™,æ‰«æå¹¶è®°å½•å­ä¸²çš„å•è¯å’Œå•è¯ä¸ªæ•°,ç”¨å¦ä¸€ä¸ª`HashMap`ä¿å­˜, (`key` æ˜¯å½“å‰å­ä¸²çš„å•è¯, `value` æ˜¯å½“å‰å­ä¸²å•è¯å‡ºç°çš„ä¸ªæ•°), å¹¶ä¸å•è¯æ•°ç»„ä¸­å•è¯å’Œå•è¯å‡ºç°ä¸ªæ•°æ¯”è¾ƒ,

1. å¦‚æœå½“å‰å•è¯ä¸åœ¨å•è¯æ•°ç»„ä¸­,é‚£ä¹ˆä»¥å½“å‰å­—ç¬¦å¼€å¤´çš„å­ä¸²ä¸å¯èƒ½æ»¡è¶³æƒ…å†µ, æå‰ç»“æŸ, å¾€åç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦çš„å­ä¸².
2. å¦‚æœå½“å‰å•è¯ä¸ªæ•°è¶…è¿‡å•è¯æ•°ç»„, ä¹Ÿä¸å¯èƒ½æ»¡è¶³, ç»“æŸ, å¾€åç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª
3. æ»¡è¶³çš„å•è¯çš„æ•°é‡(`count`)åŠ `1`.
4. æ¯”è¾ƒæ»¡è¶³çš„å•è¯æ•°é‡`(count == wordNum)`, æ»¡è¶³, è®°å½•ä¸‹å½“å‰ä¸‹æ ‡(`index`), ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦
5. æ¯æ¬¡ç§»åŠ¨ç¬¬äºŒä¸ªHashMapæ¸…ç©º, é‡æ–°è®¡ç®—

ä¾‹å­: 
```
s = "barfoothefoobarman"
words = ["foo", "bar"]
å•è¯é•¿åº¦: wordLen = 3
å•è¯ä¸ªæ•°: wordNum = 2
å­—ç¬¦ä¸²é•¿åº¦: len = 17

Words Map = {[foo:1], [bar:1]}
i=0
    å­ä¸² Map = {}
    | b a r f o o t h e f o o b a r m a n 
    å½“å‰å­ä¸²: "barfoo", æ»¡è¶³æ¡ä»¶, res=[0]
i=1
    å­ä¸² Map = {}
    b | a r f o o t h e f o o b a r m a n 
    å½“å‰å­ä¸²: "arfoot", ä¸æ»¡è¶³æ¡ä»¶, é€€å‡º, ç§»åˆ°ä¸‹ä¸€ä¸ª, res=[0] 
i=2
    å­ä¸² Map = {}
    b a | r f o o t h e f o o b a r m a n 
    å½“å‰å­ä¸²: "rfooth", ä¸æ»¡è¶³æ¡ä»¶, é€€å‡º, ç§»åˆ°ä¸‹ä¸€ä¸ª, res=[0]
.
.
.
i=9
    å­ä¸² Map = {}
    b a r f o o t h e | f o o b a r m a n 
    å½“å‰å­ä¸²: "foobar", æ»¡è¶³æ¡ä»¶, res=[0, 9] 
.
.
.
i=13, é€€å‡º, å‰©ä½™å­ä¸²é•¿åº¦ä¸æ»¡è¶³. res=[0, 9]
```
#### å¤æ‚åº¦åˆ†æ

*æ—¶é—´å¤æ‚åº¦(TC)*: `O(n * m) - næ˜¯sçš„é•¿åº¦, mæ˜¯å•è¯(words)çš„ä¸ªæ•°`.

*ç©ºé—´å¤æ‚åº¦(SC)*: `O(m)`

### è§£æ³•äºŒ

å‚è€ƒ [shichaotançš„è§£æ³•](https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13656/An-O(N)-solution-with-detailed-explanation)

åœ¨è§£æ³•ä¸€ä¸­,æˆ‘ä»¬æ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªå­—ç¬¦(`char`), è¿™æ ·å°±é€ æˆäº†å¾ˆå¤šä¸å¿…è¦çš„é‡å¤è®¡ç®—. åœ¨è§£æ³•äºŒä¸­,æ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªå•è¯(`word`), è¿™æ ·å¯ä»¥ä»¥wordé•¿åº¦åˆ†ç±»ç§»åŠ¨, ä¾‹å¦‚: `word`é•¿åº¦ä¸º`3`, é‚£ä¹ˆå°±å¯ä»¥åˆ†ä¸º`3`ç±»æ¥ç§»åŠ¨.

ä¾‹å­å¦‚ä¸‹å›¾, å¯¹äºå•è¯(`word`)é•¿åº¦ä¸º`3`, åˆ†ä¸º `i = 0, i = 1, i = 2` ä¸‰ç±»ç§»åŠ¨å•è¯çš„è·ç¦».

![substring concatenation 3](../../assets/leetcode/30.substring-with-concatenation-of-all-words-3.png)

![substring concatenation 4](../../assets/leetcode/30.substring-with-concatenation-of-all-words-4.png)

![substring concatenation 5](../../assets/leetcode/30.substring-with-concatenation-of-all-words-5.png)

ä»ä¾‹å­ä¸­,æˆ‘ä»¬å¯ä»¥å‘ç°,æŒ‰å•è¯(`word`)ç§»åŠ¨,åœ¨è§£æ³•ä¸€ä¸­,è€ƒè™‘äº†ä¸‰ç§æƒ…å†µ,é‚£ä¹ˆè§£æ³•äºŒå¯ä»¥é’ˆå¯¹è¿™ä¸‰ç‚¹è¿›è¡Œä¼˜åŒ–:

1. å½“é¢å•è¯ä¸æ»¡è¶³(ä¸åœ¨ç»™å®šå•è¯æ•°ç»„(`words`)ä¸­). 
2. å½“é¢å•è¯å‡ºç°åœ¨å•è¯æ•°ç»„(`words`)ä¸­,ä½†ä¸ªæ•°è¶…è¿‡ç»™å®šçš„ä¸ªæ•°
3. å¾€åç§»åŠ¨çš„è¿‡ç¨‹,ä¸éœ€è¦æ¯æ¬¡éƒ½æ¸…ç©º`HashMap`, é€ æˆé‡å¤è®¡ç®—, æµªè´¹èµ„æº.

å¯¹äº1ä¸­å•è¯ä¸æ»¡è¶³äº†, å¯ä»¥ç•¥è¿‡(skip)æ‰ä¸æ»¡è¶³çš„è¿™ä¸ªå•è¯å‰é¢æ‰€æœ‰çš„ç§»åŠ¨, ç›´æ¥ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•è¯. ä¾‹å¦‚:
![alt text](../../assets/leetcode/30.substring-with-concatenation-of-all-words-1.png)

å¯¹äº2ä¸­å•è¯æ»¡è¶³, ä½†æ˜¯ä¸ªæ•°è¶…è¿‡ç»™å®šä¸ªæ•°çš„æƒ…å†µ,
![alt text](../../assets/leetcode/30.substring-with-concatenation-of-all-words-2.png)

è¿™æ ·å°±ä¸éœ€è¦æ¯æ¬¡ç§»åŠ¨éƒ½æ¸…ç©º `HashMap`, è€Œæ˜¯å½“å•è¯ä¸æ»¡è¶³çš„æƒ…å†µä¸‹, æ¸…ç©º`HashMap` å³å¯.

ç›¸è¾ƒäºè§£æ³•ä¸€ä¸­, æ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªå­—ç¬¦éƒ½éœ€è¦æ¸…ç©º`HashMap`,èŠ‚çœå¾ˆå¤šæ—¶é—´çš„è®¡ç®—

#### å¤æ‚åº¦åˆ†æ

*æ—¶é—´å¤æ‚åº¦(TC)*: `O(n) - n ä¸º S çš„é•¿åº¦`

*ç©ºé—´å¤æ‚åº¦(SC)*: `O(m) - m ä¸ºå•è¯ä¸ªæ•°`


## ä»£ç  ï¼ˆJava/Python3ï¼‰

**è§£æ³•ä¸€ - æš´åŠ›**

```java
class ConcateSubstringWithAllWords {
  public List<Integer> findSubstring(String s, String[] words) {
    List<Integer> res = new ArrayList<>();
    if (s == null || words == null || s.length() < words.length || words.length == 0) return res;
    Map<String, Integer> wordsMap = new HashMap<>();
    for (String w : words) {
      wordsMap.put(w, wordsMap.getOrDefault(w, 0) + 1);
    }
    int len = s.length();
    int wordNum = words.length;
    int wordLen = words[0].length();
    if (len < wordNum * wordLen) return res;
    for (int i = 0; i < len - wordNum * wordLen + 1; i++) {
      Map<String, Integer> subMap = new HashMap<>();
      int currCount = 0;
      while (currCount < wordNum) {
        String currWord = s.substring(currCount * wordLen + i, (currCount + 1) * wordLen + i);
        if (!wordsMap.containsKey(currWord)) break;
        subMap.put(currWord, subMap.getOrDefault(currWord, 0) + 1);
        if (subMap.get(currWord) > wordsMap.get(currWord)) break;
        currCount++;
      }
      if (currCount == wordNum) {
        res.add(i);
      }
    }
    return res;
  }
}
```

** è§£æ³•äºŒ**

```java
class ConcateSubstringWithAllWords {
  public static List<Integer> findSubstring2(String s, String[] words) {
    // basic cases 
    if (s == null || words == null || s.length() < words.length || words.length == 0) return res;
    List<Integer> res = new ArrayList<>();
    final Map<String, Integer> wordsMap = new HashMap<>();
    for (final String word : words) {
      wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1);
    }
    final int len = s.length();
    final int wordNum = words.length;
    final int wordLen = words[0].length();
    for (int i = 0; i < wordLen; i++) {
      int l = i, count = 0;
      final Map<String, Integer> subMap = new HashMap<>();
      for (int r = i; r <= len - wordLen; r += wordLen) {
        final String word = s.substring(r, r + wordLen);
        // 1. ä¸æ»¡è¶³æ¡ä»¶,ç›´æ¥è·³åˆ°å•è¯åé¢, æ¸…ç©ºmap
        if (!wordsMap.containsKey(word)) {
          subMap.clear();
          count = 0;
          l = r + wordLen;
          continue;
        }
        subMap.put(word, subMap.getOrDefault(word, 0) + 1);
        if (subMap.get(word) <= wordsMap.get(word)) {
          count++;
        } else {
        // 2. æ»¡è¶³æ¡ä»¶, å½“æ—¶ä¸ªæ•°è¶…è¿‡, é‚£ä¹ˆå¾€å‰ç§»åŠ¨ç›´åˆ°ä¸ªæ•°æ»¡è¶³çš„index
          while (subMap.get(word) > wordsMap.get(word)) {
            final String first = s.substring(l, l += wordLen);
            subMap.put(first, subMap.getOrDefault(first, 0) - 1);
            if (subMap.get(first) < wordsMap.getOrDefault(first, 0)) {
              count--;
            }
          }
        }
        if (count == wordNum) {
          res.add(l);
          count--;
          final String first = s.substring(l, l += wordLen);
          subMap.put(first, subMap.get(first) - 1);
        }
      }
    }
    return res;
  }
}
```

**Python** code from **[@sunboman](https://github.com/sunboman)**

```python
from typing import List
import collections

class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not s or not words:
            return []
        w_num = len(words)
        w_len = len(words[0])
        w_count = collections.Counter(words)
        res = []
        for i in range(w_len):
            temp_count = collections.defaultdict(int)
            left = i
            for right in range(i, len(s) - w_len + 1, w_len):
                temp_word = s[right: right + w_len]
                if w_count[temp_word] > 0:
                    temp_count[temp_word] += 1
                    while temp_count[temp_word] > w_count[temp_word]:
                        temp_count[s[left: left + w_len]] -= 1
                        left += w_len
                    if right + w_len - left == w_num * w_len:
                        res.append(left)
                        temp_count[s[left: left + w_len]] -= 1
                        left += w_len
                else:
                    left = right + w_len
                    temp_count.clear()
        return res
```

## ç›¸ä¼¼é¢˜ç›®
[Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)